# 链表

缓存淘汰策略:
1. 先进先出 FIFO
2. 最少使用 LFU
3. 最近最少使用 LRU  - 时间复杂度为**o(n)** [参考hash章节](../hash/README.md) 利用散列表和双向链表实现的LRU(查询，删除，缓存时间复杂度为o(1))
>> 1. 维护一个单链表， 越靠近链表尾部的结点是越早访问的。 当有一个新的数据被访问时， 从链表头开始顺序遍历链表
>> 2. 如果此数据之前已经被缓存在链表中了， 我们遍历得到这个数据对应的结点， 并将其从原来的位置删除，然后插入到链表的头部
>> 3. 如果此数据没有在链表中
>>   1. 如果此时缓存未满， 则将此结点直接插入到链表的头部
>>   1. 如果此时缓存已满， 则链表尾结点删除， 将新的数据结点插入到链表的头部 
---
![linkedlist](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)
---
![linkedlist](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)
---
![](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)
---
* 双向链表相对单向链表 用到更多空间， 因为需要指向prev和next 
![](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)

* 链表的插入和删除 时间复杂度是o(1) 但是需要考虑到查找元素的时间 o(n)
![](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg)
---
### 链表和数组比较

1. 链表不需要连续的空间， 对内存的要求相对数组不高 
2. 链表随即访问不如数组高效 时间复杂度o(n) 
3. 数组大小固定， 一经声明就要占用整块连续内存空间， 链表支持天然扩容
4. 频繁对链表进行插入删除操作会导致内存申请和释放， 容易造成内存碎片， 可能会频繁引起GC

---
![](https://static001.geekbang.org/resource/image/4f/68/4f63e92598ec2551069a0eef69db7168.jpg)
---
### 哨兵
```

// 在数组a中，查找key，返回key所在的位置
// 其中，n表示数组a的长度
// 我举2个例子，你可以拿例子走一下代码
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 7
// a = {4, 2, 3, 5, 9, 6}  n=6 key = 6
int find(char* a, int n, char key) {
  if(a == null || n <= 0) {
    return -1;
  }
  
  // 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值
  if (a[n-1] == key) {
    return n-1;
  }
  
  // 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。
  // 之所以这样做的目的是：希望find()代码不要改变a数组中的内容
  char tmp = a[n-1];
  // 把key的值放到a[n-1]中，此时a = {4, 2, 3, 5, 9, 7}
  a[n-1] = key;
  
  int i = 0;
  // while 循环比起代码一，少了i<n这个比较操作
  while (a[i] != key) {
    ++i;
  }
  
  // 恢复a[n-1]原来的值,此时a= {4, 2, 3, 5, 9, 6}
  a[n-1] = tmp;
  
  if (i == n-1) {
    // 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1
    return -1;
  } else {
    // 否则，返回i，就是等于key值的元素的下标
    return i;
  }
}
```
---
### 注意边界问题

* 如果链表为空， 代码是否正常工作？
* 如果链表只包含一个结点时， 代码是否能正常工作？
* 如果链表只包含两个结点时， 代码是否能正常工作？
* 代码逻辑在处理头结点和尾结点的时候能否正常工作？

### 常见链表问题
1. 单链表反转
1. 链表中环的检测
1. 两个有序的链表合并
1. 删除链表倒数第n个结点
1. 求链表的中间结点